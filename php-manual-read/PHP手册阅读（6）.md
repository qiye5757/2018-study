## PHP手册阅读（六）之表达式与运算符

 任何有值的东西即为表达式。

### 运算符

 运算符分为一元表达式，二元表达式和三元表达式三种。

##### 运算符优先级

+ 如果运算符优先级相同，那运算符的结合方向决定了该如何运算。
+ 没有结合的相同优先级的运算符不能连在一起使用，例如 1 < 2 > 1 在PHP是不合法的。

		结合方向		运算符								附加信息
		无			clone new							clone 和 new
		左			[									array()
		右			**									算术运算符
		右			++ -- ~ (int)等 @					类型和递增／递减
		无			instanceof							类型
		右			!									逻辑运算符
		左			* / %								算术运算符
		左			+ - .								算术运算符和字符串运算符
		左			<< >>								位运算符
		无			< <= > >=							比较运算符
		无			== != === !== <> <=>				比较运算符
		左			&									位运算符和引用
		左			^									位运算符
		左			|									位运算符
		左			&&									逻辑运算符
		左			||									逻辑运算符
		左			??									比较运算符
		左			? :									ternary
		右	= += -= *= **= /= .= %= &= |= ^= <<= >>=	赋值运算符
		左			and									逻辑运算符
		左			xor									逻辑运算符
		左			or									逻辑运算符


##### 算数运算符

 `-` `+` `-` `*` `/` `%` `**` 其中 `**` 为幂计算

+ 取模运算符的操作数在运算之前都会转换成整数（除去小数部分）。
+ 取模运算符 % 的结果和被除数的符号（正负号）相同。即 $a % $b 的结果和 $a 的符号相同。

##### 赋值运算符(可以和算术运算符以及位运算符结合)

`=` `+=` `-=` `*=` `**=` `/=` `.=` `%=` `&=` `|=` `^=` `<<=` `>>=`

+ 在 PHP 中普通的传值赋值行为有个例外就是碰到对象 object 时，在 PHP 5 中是以引用赋值的，除非明确使用了 clone 关键字来拷贝。

+ 自 PHP 5 起，new 运算符自动返回一个引用，因此再对 new 的结果进行引用赋值在 PHP 5.3 以及以后版本中会发出一条 E_DEPRECATED 错误信息，在之前版本会发出一条 E_STRICT 错误信息。

##### 位运算符

 	$a & $b And（按位与） 		将把 $a 和 $b 中都为 1 的位设为 1。 
	$a | $b Or（按位或） 		将把 $a 和 $b 中任何一个为 1 的位设为 1。 
	$a ^ $b Xor（按位异或） 	   将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。 
	~ $a Not（按位取反） 		   将 $a 中为 0 的位设为 1，反之亦然。 
	$a << $b Shift left（左移）	 将 $a 中的位向左移动 $b 次（每一次移动都表示"乘以 2"）。 
	$a >> $b Shift right（右移） 将 $a 中的位向右移动 $b 次（每一次移动都表示"除以 2"）。 


+ 位运算符允许对整型数中指定的位进行求值和操作。
+ 位移在 PHP 中是数学运算。向任何方向移出去的位都被丢弃。左移时右侧以零填充，符号位被移走意味着正负号不被保留。右移时左侧以符号位填充，意味着正负号被保留。 
+ PHP 的 ini 设定 error_reporting 使用了按位的值。

##### 比较运算符

`==` `===` `!=` `<>` `!==` `>` `>=` `<` `<=` `<=>` `??` 其中最后两位为PHP7新出的

+ **如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行**。此规则也适用于 switch 语句。当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对。 
+ `<==>`解释（任何标量和复合类型都可以进行比较）

		$a <==> $b
		0 if $a == $b
		-1 if $a < $b
		1 if $a > $b

+ `??`解释

		$a ?? 1
		即为 empty($a)? $a : 1的简写
		

+ 比较运算符比较比较表

	+ null 和 string 比较，将null转换为字符串
	+ null/bool 和 其他的类型，将类型转换为bool
	+ object 和 object 比较

			== 比较：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。 
			=== 比较：这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。
	+ string，resource 或 number：将字符串和资源转换成数字，按普通数学比较
	+ 数组比较：具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较

+ 三元运算符

	+ 自 PHP 5.3 起，可以省略三元运算符中间那部分。
	+ 注意三元运算符是个语句，因此其求值不是变量，而是语句的结果


##### 错误控制运算符

+ PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。
+ 如果激活了 track\_errors特性，表达式所产生的任何错误信息都被存放在变量 $php\_errormsg 中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。
+   @ 运算符只对表达式有效。对新手来说一个简单的规则就是：如果能从某处得到值，就能在它前面加上 @ 运算符。例如，可以把它放在变量，函数和 include 调用，常量，等等之前。不能把它放在函数或类的定义之前，也不能用于条件结构例如 if 和 foreach 等。 

##### 执行运算符
 `` 运算符

+ 反引号运算符在激活了安全模式或者关闭了 shell_exec() 时是无效的。 

##### 递增/递减运算符

 注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和 A-Z）。递增／递减其他字符变量则无效，原字符串没有变化。 

##### 逻辑运算符

 `and` `or` `xor` `!` `&&` `||`

##### 字符串运算符

 `.` `=`

##### 数组运算符

`+` `==` `===` `!=` `<>` `!==`

array_merge()和+号的区别在于 

+ array_merge 存在相同项时，它是以数组参数列表最后一个健值为最后值（只针对关联数组）；
+ + 号，存在相同项时，是以相同项最靠前的为基准的，为最后值

数组比较： === 只有键值都相同时才为true ==只要值相同就为true

##### 类型运算符

`instanceof`

+ 用于确定某一个变量是否属于某一个类
	+ 对类使用
	+ 对继承类使用
	+ 可以使用 `!`
	+ 对接口使用

+ 也可以使用对象或者字符串
+ 如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回 FALSE
+ 如果要检查的类名称不存在，instanceof 会调用 __autoload()。另外，如果该类没有被装载则会产生一个致命错误
+ instanceof 运算符是 PHP 5 引进的。在此之前用 is_a()，但是后来 is_a() 被废弃而用 instanceof 替代了。注意自 PHP 5.3.0 起，又恢复使用 is_a() 了。 
 


