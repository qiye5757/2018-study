1.类的声明
   属性
   行为
    class  类名{
       //变量（成员属性）
       //函数（行为）
    }
    类名的注意点：有意义
                  驼峰式的命名规则
   类的成员属性前面必须有修饰词，如果不知道怎么修饰用var public
   成员属性不可以是带运算符的表达式、变量、方法或函数调用

2.对象实例化
   引用对象的属性和方法  ->
3.特殊的对象引用
 只要是对象成员就必须使用这个对象来访问这个对象内部的属性和方法
    $this->
4.构造方法
   1.是对象创建完成以后第一个 自动调用的方法
   2.方法名称比较特殊  可以和类名相同的方法名
   3.作用  对象声明的括号内部赋给构造函数的括号内部的值、
   魔术方法 __construct()  创建完对象第一个调用  两个同时存在用魔术方法
5.析构方法
   1.对象在消失之前，自动调用
   2.__destruct                                                 
   3.释放资源时候用
   4.析构方法不能带有任何参数
6.对象的三大特性:封装，继承，多态。
7.封装
  1. 将一些特殊的方法加上一个关键字private修饰,就不能拿到对象之后，就不能用对象中的方法,对象中的其他成员可以使用
  在对象中有一些方法是为其他方法服务的，用这个玩意
  2.属性的封装
  3.魔术方法
     __get()
     自动调用，是在直接访问私有成员时，自动调用。一个参数
     __set()
     自动调用，是在直接设置私有属性值时，自动调用，两个参数。
     __isset()
     如果在对象外面调用对象的私有属性isset自动调用这个方法，参数则是属性名称
     __unset()
     删除对象内的私有属性时自动调用这个魔术方法

     参数是属性名称
     这四个魔术方法的参数的调用  必须在参数前面加$
     $this->$problen
    这四个方法最好别是私有的
8.继承
    1.一般都是单继承
    2.子类通过extends继承父类
    3.private 是私有的，只能自己用，自己的子类不能用
    4.protected 这个是保护的权限，只能是自己和自己的子类中可以使用的成员，外边不可以用。
    5.public 公开的权限，所有都可以使用
9.继承中的重载(覆盖)
    1.一个类中同样的方法只能有一个
    2.在子类中可以写和父类同名的方法
    3.对象->成员
      类::成员
    4.parent::成员  使用这个访问父类中被覆盖的方法，
    5.构造方法和析构方法也能重载
    6.只要是子类的构造方法去覆盖父类中的构造方法，一定要在子类的最上面调用一下父类被覆盖的方法
    7.权限的问题；子类只能大于或者等于父类的权限，不能小于。

10.instanceof
   用于检测当前对象实例是否属于某一个类的类型
   子类的对象也属于父类，即用这个判断也成立
  final
    在PHP中final不定义常量，所以就不会使用，也不能使用final来修饰成员属性
    1.final可以修饰类   这个类不能去扩展，不能有子类(不让别人去扩展，这个类是最终的类)
    2.final可以修饰方法  这个方法就不能在子类中覆盖(不让子类去改这个方法，或者扩展这个方法，这个方法就是最终的方法)
  static  可以修饰属性和方法，不能修饰类
    1.使用static修饰成员属性，存在内存的初始化静态段，
    2.可以被所有同一个类的对象共用
    3.第一次用到类(类名第一次出现)，类在加载到内存时，就已经将静态的成员加到了内存。
    4.静态的成员一定要使用类来访问，不能用对象来访问
    5.self 可以在类中的方法中，代表自己类的($this),在外边用类名加::
    6.静态成员一旦被加载，只有脚本结束才释放
    7.在静态方法中，是不能访问非静态成员
    8.只要是能使用静态的环境下声明方法，就最好使用静态方法，效率高。
  const 
    1.在类里面不能使用define定义常量
    2.采用const修饰的成员属性为常量，也只能修饰成员属性
    3.常量建议使用大写，不能使用$
    4.常量一定要在声明时就给好初值
    5.常量的访问方式和静态的访问方式相同，但只能读  
        1.在类外部使用  类名::常量名
	2.在类的内部使用  self::常量名
11.设计模式:为完成某一功能的最好的方法
    单态设计模式:一个类只能声明一个对象--最适合PHP使用这个设计模式
    1.如果想让一个类只能有一个对象，就要先让这个类不能创建对象，将构造方法私有化
    2.在类的内部使用一个静态方法创建一个对象，使用一个静态属性。
12.魔术方法(PHP独有的)
    特点:自动调用，但不同的魔术方法有自己的调用时机
         都是以__开始的方法
	 所有的魔术方法，方法名都是固定的 
         如果不写就不存在，依旧没有默认的功能 
    1.类中通用的方法__toString
         是在直接使用echo  print  printf输出一个对象引用时，自动调用这个方法。
	 作用:将对象的基本信息放在__toString()方法内部，形成字符串返回
	 这个方法不能有参数，而且必须返回一个字符串
    2.克隆对象__clone()方法
           1. $p1 = $p2
	    这个直接是把$p2的引用赋给了$p1
	    $p1 = clone $p2  克隆
	   2.__clone()是在克隆对象时自动调用
	   3.作用:和构造方法一样是对新克隆对象进行初始化。
	   4.在这个方法中$this代表的是副本，所以就可以给所有的副本赋值
    3.通过__call()方法处理错误调用
          1.就是在调用一个对象中不存在的方法时，自动调用
	  2.有两个参数(必须写),第一个参数，调用的不存在的方法的方法名，第二个参数，调用不存在的方法的的参数。
	  3.作用:可以写提示
	     可以将方法的功能相似，但方法名还要不同的，就可以采用这个方法
13.对象串行化(序列化)：对象转为字符串(不用看懂)
   将字符串再转回对象  叫反串行化
    目的：1.将对象在网络中传输
          2.将对象长时间保存
第一种串行化方式
    1.序列化过程
       p为一个对象
       //将对象串行化
       $str = serialize($p);
       //将字符串保存在这个文件中
       file_put_contents("obkstr.txt",$str);
    2.反序列化
       
     //从文件中读出字符串
     $str = file_get_contents("objstr.txt");
     //反串行化
     $p = unserialize($str)
    和后面学的session有关
__sleep()  在串行化时自动调用的方法
作用:可以设置需要串行化的对象的属性
只要在这个方法中返回一个数组，在数组中声明了哪个属性名，哪个属性就会被串行化。默认这个方法，全部属性都串行化。

__weakup  在反串行化时自动调用的方法
作用:对串行化回来的对象进行初始化，和下面两个方法作用相似

只要有对象诞生，就得给对象初始化
 __construct()
 __clone()
 14.数组的串行化json  
   json_encode 对变量进行json编码
   json_decode 对json格式的字符串进行编码，第二个参数true反串行化为数组
15.魔术方法__set_state()
  1.eval函数  ----   检查并执行php代码
     $str = "echo 'abc';";
     eval($str);
  2.var_export与var_dump类似，只不过其返回的是一个合法的php代码。var_export($a)输出的是一个字符串。加上一个true就可以将刚才的哪个字符串赋给一个变量了，与eval相搭配就变成了输出语句了。
  3.__set_state，就是在使用var_export方法时，导出一个类的时候自动调用的方法
  这个方法有强制要求
  必须是静态的函数，必须有一个参数为数组参数，其中包含按array('a'=>value,...)格式排列的类属性
16.php5.3以后新增的魔术方法
    1.__invoke()在对象实例之后，直接像变量函数一样调用时自动调用这个方法
    对象加括号不行，如果加这个魔术方法，就行
    可以有参数__invoke()有几个参数，这个就有几个参数
    2.__callStatic必须是公有的，静态的方法.
      __call 不支持静态方法，__callStatic支持.
      eg: a::$abc;
         $abc不存在，调用这个方法。
17.自动加载类
     魔术函数__autoload 唯一一个可以写在类外
     只要在这个脚本中需要加载类的时候(必须用到类名)就会自动调用这个方法。
     文件名全是小写的，类名全是大写的
     function __autoload($classname){
         echo "$classname<br>";
         include strtolower($lassname).'.class.php';
     }
18.抽象方法和抽象类
     1.什么事抽象方法?
     定义:一个方法如果没有方法体(一个方法不适用{},直接使用分号结束的方法，才是没有方法体的方法)，则这个方法就是抽象方法。
     声明一个方法，不适用{}而直接用分号结束
     如果是抽象方法，必须使用abstract(抽象关键字来修饰).
     2.什么是抽象类
     如果一个类中有一个方法是抽象方法，则这个类就是抽象类 
     如果声明一个抽象类，则这个类必须要使用abstract来修饰

     3.注意的事项:
       1.只要使用abstract修饰的类，就是抽象类
       2.抽象类是一种特殊的类，特殊(在抽象类中可以由抽象方法)。
       3.除了在抽象类中可以有抽象方法以外，和正常的类完全一样
       4.抽像类不能实例化(不能创建对象)
       5.如果看见抽象类，就必须写这个类的子类，将抽象类中的抽象方法覆盖(加上方法体)
       6.子类必须全部实现抽象方法，这个子类才能创建对象，如果只实现部分，那么还有抽象方法，类还是一个抽象类
    4.抽象方法的作用:规定了子类必须要有这个方法的实现，功能交给子类  只写出来结构，而没有实现，交个具体的子类(按自己的功能去实现)
    5.抽象类的作用:就是要求子类的结构，所以抽象类是一个规范.
19.抽象类是一种抽象的类，接口是一种特殊的抽象类，接口也是一种特殊特殊类
   1.抽象类和接口中都有抽象方法
   2.抽象类和接口都不能创建实例对象
   3.抽象类和接口的使用意义也就是作用相同

 接口和抽象类相比，特殊在哪里?
    1.接口中的方法，必须全是抽象方法,所以在接口中的方法不需要abstract，直接使用分号结束即可
    2.接口中的成员属性，必须是常量
    3.所有的权限必须是公有的public
    4.声明接口不使用class ，而是interface
     $this self parent  const定义常量
20.接口的一些细节
    1.可以使用extents让一个接口继承另一个接口(接口和接口只有扩展新抽象方法，没有覆盖的关系)
    2.可以使用一个类来实现接口中的全部方法，也可以使用一个抽象类来实现接口中的部分方法(类与接口，抽象类与接口--覆盖--重写--事项接口中的抽象方法)
    3.就不要使用extends这个关键字，使用implements实现。
    extends，这个在php中，一个类只能有一个父类。
    4.一个类可以在继承另一个类的同时，使用implements实现一个接口，可以实现多个接口(一定要先继承在实现接口)
    5.实现多个接口只需要使用逗号，分开
    eg:class abc extends a inplements b,c,d{
         function test(){
	 
	 }
    }
21.多态
    多态特性
    程序扩展准备
    技术：
    必须有继承关系，父类最好是借口或者抽象类
    只有复合类型才有的特点:数组，类，接口可以当做参数来传递，有限制，即参数只能是规定的类型，有点像强类型语言      
22.魔术常量
    __CLASS__  返回该类被定义时声明的名字
    METHOD  
23.命名空间---名字空间  php5.3以后
   解决常量，函数，类名字 重复的问题
   1.namespace来声明
      namespace meizi;
      const AAA = 1;
      class demo(){
      
      }
      function test(){
      
      }
     test();
     \meizi\test();
   2.在namespace声明命名空间的代码上面，不能有任何PHP代码和HTML内容输出(除了declare,定义源文件编码方式的)。
   3.定义子命名空间
     namespace meizi\pl;
   4.在同一个文件中定义多个命名空间
        简单组合语法
	大括号语法(不要在大括号外部加任何代码)
	全局代码必须使用一个不带名称的namespace语句加上{}
   5.命名空间名词定义
        非限定名称
	限定名称
	完全限定名称
	完全限定名称的函数，是在编译的时候解析
	非限定名称和限定名称，是在运行的时候解析的
   6.函数有变量函数，类可以将类名赋给一个变量，然后new这个变量，这两种都是动态声明，
   eg:
        namespace a;
	function b(){
	    echo 'aaaaaaaaaaa'.'<br>';
	}

	$c = "\a\b";   //这块b必须为完全限定或者限定名称
	$c();
    __NAMESPACE__  包含当前命名空间名称的字符串
    namespace  可用于显式访问当前命名空间或者子命名空间中的元素，他等价于类中的self
    7.对比较长的命名空间起别名
       use  net\lampbrother\www as lamp; 
       use   net\lampbrother\www   默认是  www


       use \hello   导入一个全局的类
       然后在该命名空间中可以使用这个类 不加\

       即类不导入该命名空间就不能使用，或者使用\，
       而对象和常量在这个命名空间中找不到 就会自动去全局搜寻








